from collections import deque
from CheckNeighbours import check_neighbours

'''
BFS algorithm 
- Takes as input the dimension and probability of a maze
- Explores in the order of oldest cells in the fringe
- Constructs the shortest path from source to goal
'''


def bfs_traversal(maze, dim):
    closed_set = []
    fringe = deque()
    exploration_steps = 0
    avg_fringe_length = 0
    max_fringe_length = 0
    # initial state of fringe
    fringe.append((0, 0))

    while len(fringe) != 0:
        # pop tuple from left and analyze
        (x, y) = fringe.popleft()
        exploration_steps = exploration_steps + 1
        if (x, y) not in closed_set:
            # if current cell is the goal
            if (x, y) == (dim-1, dim-1):
                result_dict = {
                    "is_solvable": True,
                    "total_steps": exploration_steps,
                    "max_fringe_length": max_fringe_length,
                    "avg_fringe_length": avg_fringe_length,
                    "closed_set": closed_set
                }
                return result_dict
            else:
                if maze[x][y].value != 1:
                    # call method to explore neighbouring cells of current cell
                    check_neighbours(maze, dim, x, y, fringe, closed_set)
                    fringe_length = len(fringe)
                    if fringe_length > max_fringe_length:
                        max_fringe_length = fringe_length
                    avg_fringe_length = avg_fringe_length + (fringe_length - avg_fringe_length) / exploration_steps
                # add current cell to closed set
                closed_set.append((x, y))
    print "No Path"
    result_dict = {
        "is_solvable": False,
        "total_steps": exploration_steps,
        "max_fringe_length": max_fringe_length,
        "avg_fringe_length": avg_fringe_length,
        "closed_set": closed_set
    }
    return result_dict


'''
if result == 0:
    print "No Path Found"
    maze_runner.visualize_maze(maze)
else:
    # visualize path generated by BFS on maze
    path = maze_runner.get_path(m, n, maze)
    maze_runner.trace_path(maze, path)
'''